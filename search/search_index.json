{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rye: An Experimental Package Management Solution for Python","text":"<p>Rye is Armin's personal one-stop-shop for all his Python needs.  It installs and manages Python installations, helps working with <code>pyproject.toml</code> files, installs and uninstalls dependencies, creates and updates virtualenvs behind the scenes.  It supports monorepos and global tool installations.</p> <p>Rye is an experimental endeavour to build a new type of packaging experience to Python inspired by <code>rustup</code> and <code>cargo</code> from Rust.  It's not yet production ready but feedback and suggestions are greatly appreciated.</p> <ul> <li>Getting Started is a helpful guide for installation and basics.</li> <li>Tools shows how to use Rye as <code>pipx</code> replacement.</li> <li>Philosophy tells you more about why this project exists and the ideas behind it.</li> <li>The Changelog lists all recent changes to Rye.</li> <li>A 9 Minute Introduction Screencast, for when you want to watch rather than read.</li> </ul> <p>Ways to provide feedback:</p> <ul> <li>Issue Tracker if you run into bugs</li> <li>Discussions if you have ideas or want to discuss the project</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>There is currently no actual release of Rye.  The latest main branch revision is the one you can install as mainline should always be stable.  Here are the most recent changes however.</p>"},{"location":"changelog/#may","title":"May","text":"<ul> <li> <p>Rye now includes a <code>publish</code> command for publishing Python packages to a   package repository.  #86</p> </li> <li> <p>Script declarations in <code>pyproject.toml</code> now permit chaining and custom   environment variables.  #153</p> </li> <li> <p>Added <code>tools install</code> and <code>tools uninstall</code> as aliases for <code>install</code> and   <code>uninstall</code> and added <code>tools list</code> to show all installed tools.</p> </li> <li> <p>Rye is now capable of downloading a selected set of PyPy releases.  To do   so use <code>rye pin pypy@3.9.16</code> or any other supported PyPy release.</p> </li> <li> <p>Custom cpython toolchains are now registered just as <code>cpython</code> rather   than <code>custom-cpython</code>.</p> </li> <li> <p>Rye now supports Python down to 3.7.</p> </li> <li> <p>Rye's <code>self</code> command now includes a <code>completion</code> subcommand to generate   a completion script for your shell.</p> </li> <li> <p>The downloaded Python distributions are now validated against the   SHA-256 hashes.</p> </li> <li> <p>Rye now builds on windows.  This is even more experimental though   than support for Linux and macOS.</p> </li> <li> <p>Added <code>--features</code> and <code>--all-features</code> for <code>lock</code> and <code>sync</code>.</p> </li> <li> <p>Rye will now look at the <code>RYE_HOME</code> to determine the location of the   <code>.rye</code> folder.  If it's not set, <code>$HOME/.rye</code> is used as before.</p> </li> <li> <p>Rye now has a most consistent handling for virtualenv versions.  If   <code>.python-version</code> is provided, that version is used.  Otherwise if   <code>requires-python</code> is set in the <code>pyproject.toml</code>, that version is used   instead.  When a new project is created the <code>.python-version</code> file is   written and the current latest cpython version is picked.</p> </li> <li> <p>It's now possible to explicitly set the <code>name</code> of the project when   initializing a new one.</p> </li> <li> <p>Rye's <code>init</code> command now attempts to initialize projects with <code>git</code> and   will automatically create a <code>src/project_name/__init__.py</code> file.</p> </li> <li> <p>Rye can now also generate a license text when initializing projects.</p> </li> </ul>"},{"location":"changelog/#april","title":"April","text":"<ul> <li> <p>Rye now supports negative (exclusion) dependencies.  These can be used to   prevent a dependency from installing, even if something else in the graph   depends on it.  Use <code>rye add --exclude package-name</code> to add such a dependency.</p> </li> <li> <p><code>sync</code> now accepts <code>--no-lock</code> to prevent updating the lock file.</p> </li> <li> <p>Rye's <code>add</code> command now accepts a <code>--pre</code> parameter to include pre-release.</p> </li> <li> <p>Rye's <code>pin</code> command now updates the pyproject.toml requires-python.</p> </li> <li> <p>Rye's <code>install</code> command now accepts a <code>--include-dep</code> parameter to include   scripts from one or more given dependencies.</p> </li> <li> <p>Rye now honors <code>requires-python</code> in the <code>add</code> command.  This means the the   initial resolution will not pick a version higher than what's supported by   the lower boundary.</p> </li> <li> <p>When installing packages as global tools, a warning is now emitted if there   were no scripts in the package.  Additionally installing packages from local   paths and zip files is now supported.</p> </li> <li> <p>A <code>rye self update</code> command was added to compile and install the latest   version via cargo.</p> </li> <li> <p>Added more convenient ways to install from git/urls by supplying a <code>--git</code>   or <code>--url</code> parameter.  This will behind the scenes format a PEP 508 requirement   string.</p> </li> <li> <p>Added a <code>shell</code> command which will spawn a shell with the virtualenv activated.</p> </li> <li> <p>Added a <code>make-req</code> command to conveniently format out PEP 508 requirement   strings from parts.</p> </li> <li> <p>The internal virtualenv used to manage <code>pip-tools</code> and other libraries now   automatically updates when necessary.</p> </li> <li> <p><code>rye toolchain register</code> can now be used to register a local python installation   as toolchain with rye.</p> </li> <li> <p><code>rye build</code> was added to allow building <code>sdist</code> and <code>bdist_wheel</code> distributions.</p> </li> <li> <p>Rye now correctly handles whitespace in folder names.</p> </li> </ul>"},{"location":"philosophy/","title":"Philosophy and Vision","text":"<p>Rye was built to solve my problems.  Here is what was on my mind when I built it:</p> <ul> <li> <p>Virtualenvs: while I personally do not like virtualenvs that much, they are   so widespread and have reasonable tooling support, so I chose this over   <code>__pypackages__</code>.</p> </li> <li> <p>No Default Dependencies: the virtualenvs when they come up are completely void   of dependencies. Not even <code>pip</code> or <code>setuptools</code> are installed into it. Rye   manages the virtualenv from outside the virtualenv.</p> </li> <li> <p>No Core Non Standard Stuff: Rye (with the exception of it's own <code>tool</code> section   in the <code>pyproject.toml</code>) uses standardized keys. That means it uses regular   requirements as you would expect. It also does not use a custom lock file   format and uses <code>pip-tools</code> behind the scenes.</p> </li> <li> <p>No Pip: Rye uses pip, but it does not expose it. It manage dependencies in   <code>pyproject.toml</code> only.</p> </li> <li> <p>No System Python: I can't deal with any more linux distribution weird Python   installations or whatever mess there is on macOS. I used to build my own Pythons   that are the same everywhere, now I use indygreg's Python builds.   Rye will automatically download and manage Python builds from there. No compiling,   no divergence.</p> </li> <li> <p>Project Local Shims: Rye maintains a <code>python</code> shim that auto discovers the   current <code>pyproject.toml</code> and automatically operates below it. Just add the   shims to your shell and you can run <code>python</code> and it will automatically always   operate in the right project.</p> </li> </ul>"},{"location":"philosophy/#what-could-be","title":"What Could Be?","text":"<p>There are a few shortcomings in the Python packaging world, largely as a result of lack of standardization. Here is what this project ran into over the years:</p> <ul> <li> <p>No Python Binary Distributions: CPython builds from python.org are completely   inadequate. On some platforms you only get an .msi installer, on some you   literally only get tarballs. The various Python distributions that became popular   over the years are diverging greatly and cause all kinds of nonsense downstream.   This is why this Project uses the indygreg standalone builds. I hope that with   time someone will start distributing well maintained and reliable Python builds   to replace the mess we are dealing with today.</p> </li> <li> <p>No Dev Dependencies: Rye currently needs a custom section in the <code>pyproject.toml</code>   to represent dev dependencies. There is no standard in the ecosystem for this. It   really should be added.</p> </li> <li> <p>No Local Dependency Overlays: There is no standard for how to represent local   dependencies. Rust for this purpose has something like <code>{ path = \"../foo\" }</code>   which allows both remote and local references to co-exist and it rewrites them   on publish.</p> </li> <li> <p>No Exposed Pip: pip is intentionally not exposed. If you were to install something   into the virtualenv, it disappears next time you sync. If you symlink <code>rye</code> to   <code>~/.rye/shims/pip</code> you can get access to pip without installing it into the   virtualenv. There be dragons.</p> </li> <li> <p>No Workspace Spec: for monorepos and things of that nature, the Python ecosystem   would need a definition of workspaces. Today that does not exist which forces every   tool to come up with it's own solutions to this problem.</p> </li> <li> <p>No Basic Script Section: There should be a standard in <code>pyproject.toml</code> to   represent scripts like <code>rye</code> does in <code>rye.tools.scripts</code>.</p> </li> </ul>"},{"location":"philosophy/#the-vision","title":"The Vision","text":"<p>This describes of what I envision Python packaging and project management could look like in an ideal world:</p>"},{"location":"philosophy/#the-rust-experience","title":"The Rust Experience","text":"<p>Coming from a Rust environment there are two tools which work together: <code>rustup</code> and <code>cargo</code>.  The first one of those is used to ensure that you have the correct Rust toolchain on your machine.  Rust greatly prefers binary distributions of the language from the official website over external distributions.</p> <p><code>cargo</code> is the main entry point to development in Rust.  It acts as the tool to trigger test runs, start the build process, shell out to the documentation building tool, linters but also things such as workspace management, dependency management and package publishing.</p> <p>Crucially a very important aspect of the Rust development experience is the strong commitment to semver and the built-in support for it.  This goes very deep.  The resolver for instance will deduplicate matching dependencies throughout the graph. This means that if four libraries depend on <code>libc@0.2</code>, they will all resolve to that dependency.  However if another need arises for <code>libc@1.0</code>, then it's possible for the dependency graph to result in both being loaded!</p> <p>The ecosystem greatly depends on this.  For instance when a new major release is made of a very core library, in some cases extra care is taken to unify the now incompatible versions by re-exporting core types from the newer to the older version.  Thus it's for instance possible for <code>important-lib@0.2.32</code> to depend on <code>important-lib@1.0</code> internally so it can make the transition easier.</p> <p>Additionally Rust heavily leverages lockfiles.  Whenever you compile, the dependencies are locked in place and future builds reuse the same dependency versions unless you update.</p> <p>Most importantly though the Rust ecosystem has embraced <code>rustup</code> and <code>cargo</code> that the vast majority of people are using these tools on a daily basis.  Even developers who pick other tools like buck, are still using <code>cargo</code> regularly.</p>"},{"location":"philosophy/#going-python","title":"Going Python","text":"<p>Rye wants to explore if such an experience is possible with Python.  I believe it can! There is quite a lot of the ecosystem that can be leveraged for this purpose but there is even more that would need to be built.</p> <p>Important note: when you read \"rye\" in the context of the document it talks about what a potential tool like rye could be.  It might as well be that one of the many tools that exist today, turn into that very tool that is described here.</p> <p>My sentiment is that unless \"the one tool\" can emerge in the Python world, the introduction of yet another tool might be a neg-negative to the ecosystem.  Plenty of tools have been created over the years, and unfortunately it hasn't been able to rally the majority of the Python community behind any tool.  I do however believe it is possible.</p>"},{"location":"philosophy/#bootstrapping-python","title":"Bootstrapping Python","text":"<p>I believe the right approach is that &gt;95% of users get a Python distribution via <code>rye</code> and not to have <code>rye</code> pick up a system installed Python distribution.  There are good reasons for using a system Python installation, but it should be the exception not the rule.  Most importantly because a Python distribution that <code>rye</code> puts in place can be made to have reliable and simple rules that do not differ between systems.</p> <p>A huge cause of confusion and user frustration currently comes from Linux distribution specific patches on top of Python that break tools and change behavior, particularly in the python packaging ecosystem.</p> <p>Bootstrapping Python via an independent tool has other benefits as well.  It for instance allows much easier cross-python version testing via tox or CI.</p> <p>What needs to be done:</p> <ul> <li>Provide widely available Python builds, with largely standardized structure   retrievable from the internet. PEP 711 is a step   in that direction.</li> </ul>"},{"location":"philosophy/#a-stronger-resolver","title":"A Stronger Resolver","text":"<p>Today there are a ton of different resolvers in the Python ecosystem.  Pip has two, poetry has one, pdm has one, different independent Python and Rust resolvers exist on top of that. Resolvers are important, but unfortunately are are both too many and too many issues with the existing ones.  Here is what I believe a resolver needs to be able to accomplish:</p> <ul> <li> <p>Allow resolving across markers: most resolvers in the Python ecosystem today can only   resolve for the current interpreter and platform (eg: pip, pip-tools).  This means it cannot   create a resolution that is equally valid for a different platform.  In parts this is   a problem because of how environment markers in Python are defined.  They allow a level of   expressiveness that cannot be reflected by most tools, however a subset could be supported.</p> </li> <li> <p>Multi-version resolution support: this is a bit foreshadowing, but I believe for a   variety of reasons it needs to be possible for a resolver to not unify all requirements   to a single version, but to support multiple independent resolutions across major versions   of libraries.  A future resolver should be able to permit <code>package==2.0</code> and <code>package==1.1</code>   to both be resolved for different parts of the tree.</p> </li> <li> <p>Resolver API: access to the resolver is important.  For editor plugins, or custom   tools it's always necessary to be able to resolve packages.  For instance if you want   something as trivial as \"add latest supported version of 'flask' to my <code>pyproject.toml</code>\"   you need to be able to work with the resolver.</p> </li> <li> <p>Filters: I strongly believe that a good resolver also needs a filter on top.  For   instance it must be possible for a developer to restrict the resolver to stay within the   bounds of the target Python version and to never upgrade into a tree containing Python   versions that are too new.  Likewise for supply chain safety a resolver should be able to   restrict itself to a set of vetted dependencies.</p> </li> </ul> <p>What needs to be done:</p> <ul> <li>Create a reusable resolver that can be used by multiple tools in the ecosystem.</li> <li>Make the resolver work with the proposed metadata cache</li> <li>Expose the resolver as API for multiple tools to use.</li> <li>Add a policy layer into the resolver that can be used to filter down the dependencies   before use.</li> </ul>"},{"location":"philosophy/#metadata-caches","title":"Metadata Caches","text":"<p>Because of the rather simplistic nature of Python packages and package indexes a resolver will always be restricted by the metadata that it can reliably pull.  This is particularly bad if the system needs to fall back to <code>sdist</code> uploads which in the worst case requires executing python code to determine the dependencies, and those dependencies might not even match on different platforms.</p> <p>However this is a solvable problem with sufficient caching, and with the right design for the cache, this cache could be shared.  It might even be quite interesting for PyPI to serve up \"fake\" metadata records for popular sdist only packages to help resolvers.  This might go a long way in improving the quality of the developer experience.</p> <p>What needs to be done:</p> <ul> <li>Local metadata caches are added for the resolver to use</li> <li>PyPI gains the ability to serve dependency meta data</li> </ul>"},{"location":"philosophy/#lockfiles","title":"Lockfiles","text":"<p>It's unclear if a standard can emerge for lock files given the different requirements, but a Python packaging solution needs to have support for these.  There are a lot of different approaches to lockfiles today (poetry and pdm for instance have them) but it's not entirely clear to me that the way they are handled today is sufficiently pragmatic to enable a tool that is based on lockfiles to get majority adoption.</p> <p>The reason in part relates the suboptimal situation with resolvers (eg: large projects can take ten minutes or longer to dependency check in poetry), on the other hand however also because of the reality of how dependencies are currently declared.  For instance certain libraries will \"over\" depend on third party libraries, even if they are not needed for a developer.  These pulled in dependencies however will still influence the resolver.</p> <p>Most importantly a good lockfile also covers platforms other than the current developer's machine.  This means that if a project supports Windows and Linux, the lockfile should be handling either dependency trees.  This is what cargo accomplishes today, but cargo has a a much simpler problem to solve here because it has perfect access to package metadata which resolvers in Python do not have today.  What is also problematic in Python is that certain parts of the dependency tree can be version dependent.  In Rust a library A either depends on library B or it does not, but it does not depend on it conditional to a Python version.</p> <p>The total expressiveness of Python dependencies is challenging.  The lack of good metadata access for the resolver combined with the ability to make dependencies optional conditional to the Python version is tricky by itself.  The complexity however is compounded by the fact that the resolver needs to come to a solution that can only result in a single resolved version per package.</p> <p>What needs to be done:</p> <ul> <li>Experiment with a restricted lock format that satisfies a subset of what markers provide   today, that strikes a good balance.</li> <li>Provide lockfile support as part of the resolver library.</li> </ul>"},{"location":"philosophy/#upper-bounds-multi-versioning","title":"Upper Bounds &amp; Multi Versioning","text":"<p>Resolving Python dependencies is particularly challenging because a single solution must be found per package.  A reason this works at all in the Python ecosystem is that most libraries do not set upper bounds.  This means that they will be eagerly accepting future libraries even at the cost of not supporting them.  That's largely possible because Python is a dynamic language and a lot of flexibility is usually possible here.  However with increased utilization of type information in the Python world, and maybe with stronger desires for proper locking, it might be quite likely that upper version bounds become more common.</p> <p>Once that happens however, the Python ecosystem will quite quickly run into blocking future upgrades until the entire dependency graph has moved up which creates a lot of friction. Other ecosystems have solved this problem by strictly enforcing semver semantics onto packages and by permitting multiple semver incompatible libraries to be loaded simultaneously.  While usually a library is only allowed to permit on a single version of a dependency, that dependency can exist in different versions throughout the dependency tree.</p> <p>In Python there is a perceived worry that this cannot be accomplished because of how site-packages, <code>PYTHONPATH</code> and <code>sys.modules</code> works.  However I believe these to be solvable issues.  On the one hand because <code>.pth</code> files can be used to completely change how the import system works, secondly because the <code>importlib.metadata</code> API is strong enough these days to allow a package to resolve it's own metadata.  The combination of the two can be used to \"redirect\" imports in <code>sys.modules</code> and import statements to ensure that if a library imports a dependency of itself, it ends up with the right version.</p> <p>What needs to be done:</p> <ul> <li>Add a new metadata key to <code>pyproject.toml</code> that declares that a package supports multi-versioning</li> <li>Enforce semver semantics on multi-version dependencies</li> <li>Provide an import hook that provides multi-version imports as part of Rye</li> <li>Relax the resolver to permit multiple solutions for multi-version dependencies</li> </ul>"},{"location":"philosophy/#workspaces-and-local-multi-path-references","title":"Workspaces and Local / Multi Path References","text":"<p>With growing development teams one of the most frustrating experiences is the inability to break up a monolithic Python module into smaller modules without having to constantly publish minor versions to a package index.  The way the Rust ecosystem deals with this issue is two-fold: one the one hand Rust supports workspaces natively.  Workspaces share dependencies and the resolver results.  The equivalent in Python would be that a workspace shares a virtualenv across all of the projects within in.  The second way in which Rust solves this problem is to permit a dependency to both support declaration of the package name, index but also local reference.</p> <p>While also Rust does not permit a crate to be published to a package index with references to packages outside of the index, a separate rewrite step kicks in ahead of publish to clean out invalid dependency references.  If no valid reference remains, the package will not publish.</p> <p>What needs to be done:</p> <ul> <li>requirement declarations need to be expanded to support defining the name of the index where   they can be found, and optional local path references.</li> </ul>"},{"location":"philosophy/#every-project-in-a-virtualenv","title":"Every Project in a Virtualenv","text":"<p>While virtualenv is not by favorite tool, it's the closest we have to a standard.  I proposed that there is always one path for a virtualenv <code>.venv</code> and when Rye manages it, users should not interact with it manually.  It's at that point rye's responsibility to manage it, and it shall manage it as if it was a throw-away, always re-creatable scratch-pad for dependencies.</p> <p>Preferably over time the structure of virtualenvs aligns between different Python versions (eg: Windows vs Linux) and the deeply nested <code>lib/py-ver/site-packages</code> structure is flattened out.</p> <p>What needs to be done:</p> <ul> <li>Agree on a name for where managed virtualenvs are placed (eg: <code>.venv</code> in the workspace root)</li> </ul>"},{"location":"philosophy/#dev-and-tool-dependencies","title":"Dev and Tool Dependencies","text":"<p>Another topic that is currently unresolved across tools in the ecosystem is how to work with dependencies that are not used in production.  For instance it's quite common that a certain dependency really only matters on the developer's machine.  Today pdm and some other tools have custom sections in the <code>pyproject.toml</code> file to mark development dependencies, but there is no agreement across tools on it.</p> <p>What needs to be done:</p> <p>There needs to be an agreed upon standard for all tools.  See this discussion</p>"},{"location":"philosophy/#opinionated-defaults","title":"Opinionated Defaults","text":"<p>Python against PEP-8's wishes just has too many ways in which things can be laid out.  There should be a much stronger push towards encouraging common standards:</p> <p>What needs to be done:</p> <ul> <li>Rye shall ship with the one true formatter</li> <li>Rye shall ship with the one true linter</li> <li>Rye shall always create a preferred folder structure for new projects</li> <li>Rye shall loudly warn if <code>package-foo</code> does not provide a <code>package_foo</code> module</li> </ul>"},{"location":"philosophy/#existing-tools","title":"Existing Tools","text":"<p>Some of the existing tools in the ecosystem are close, and there is a good chance that some of these might be able to combine forces to create that one-true tool.  I hope that there is enough shared interest, that we don't end up with three tools that all try to be Rye.</p>"},{"location":"guide/","title":"Getting Started","text":"<p>Rye is still a very experimental tool, but this guide is here to help you get started.  Before we dive into the installation and basic usage guide it's important for you to understand what Rye actually is.</p> <p>Rye is a one-stop-shop tool.  The idea is that as a Python developer all you need to know is Rye, because Rye is your start into the experience.  As a Rye user you do not even need to install Python yourself as Rye does this for you. This means to use Rye, you just need to install Rye, the rest is done by Rye itself.</p> <p>Once Rye is on your system, it can automatically install Python interpreters for you, install packages from package indexes, manage virtualenvs behind the scenes and more.</p> <p>Interested?  Then head over to Installation to learn about how to get Rye onto your system.  Once that is done, read the Basics to learn about how Rye can be used.</p>"},{"location":"guide/basics/","title":"Basics","text":"<p>To use Rye you need to have a <code>pyproject.toml</code> based Python project.  For this guide you can create one with <code>rye init</code> which will create a new folder with a new project inside:</p> <pre><code>rye init my-project\ncd my-project\n</code></pre> <p>The following structure will be created:</p> <pre><code>.\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 my_project\n        \u2514\u2500\u2500 __init__.py\n</code></pre> <p>A <code>pyproject.toml</code> is used to store metadata about your project as well as some Rye configuration.  Most of Rye's commands will require a <code>pyproject.toml</code> to work.  Note that Rye today does not support <code>setup.py</code> based projects.  Note that when Rye initializes a project it also writes a <code>.python-version</code> file.  This file contains the version number of the Python version that should be used for this project.  It can be changed by running <code>rye pin</code>.  For instance to tell Rye to use Python 3.10:</p> <pre><code>$ rye pin 3.10\n</code></pre>"},{"location":"guide/basics/#first-sync","title":"First Sync","text":"<p>Once that is done, you can use <code>rye sync</code> to get the first synchronization.  After that, Rye will have created a virtualenv in <code>.venv</code> and written lockfiles into <code>requirements.lock</code> and <code>requirements-dev.lock</code>.</p> <pre><code>rye sync\n</code></pre> <p>The virtualenv that Rye manages is placed in <code>.venv</code> next to your <code>pyproject.toml</code>. The first time you run this you will notice that Rye automatically downloaded and installed a compatible CPython interpreter for you.  If you have already another Python installation on your system it will not be used!  For more information about this behavior read about toolchains.</p> <p>You can activate and work with it as normal with one notable exception: the Python installation in it does not contain <code>pip</code>.  If you have correctly installed Rye with the shims enabled, after the sync you can run <code>python</code> and you will automatically be operating in that virtualenv, even if it's not enabled.  You can validate this by printing out <code>sys.prefix</code>:</p> <pre><code>python -c \"import sys; print(sys.prefix)\"\n</code></pre> <p>It will print out the full path to the managed virtualenv.</p>"},{"location":"guide/basics/#adding-dependencies","title":"Adding Dependencies","text":"<p>Use the <code>add</code> command to add dependencies to your project.</p> <pre><code>rye add \"flask&gt;=2.0\"\n</code></pre> <p>Note that after <code>add</code> you need to run <code>sync</code> again to actually install it.</p>"},{"location":"guide/basics/#remove-a-dependency","title":"Remove a Dependency","text":"<p>Use the <code>remove</code> command to remove a dependency from the project again.</p> <pre><code>rye remove flask\n</code></pre>"},{"location":"guide/basics/#working-with-the-project","title":"Working with the Project","text":"<p>To run executables in the context of the virtualenv you can use the <code>run</code> command.  For instance if you want to use <code>black</code> you can add and run it like this:</p> <pre><code>rye add black\nrye sync\nrye run black\n</code></pre> <p>To activate the virtualenv, use the standard methods:</p> UnixWindows <pre><code>. .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>To deactivate it again run <code>deactivate</code>:</p> <pre><code>deactivate\n</code></pre>"},{"location":"guide/config/","title":"Configuration","text":"<p>Most of Rye's configuration is contained within the <code>pyproject.toml</code> file.  There is however also a bit of global configuration to influence how it works.</p>"},{"location":"guide/config/#changing-home-folder","title":"Changing Home Folder","text":"<p>By default Rye places all it's configuration in <code>~/.rye</code> on Unix and <code>%USERPROFILE%\\.rye</code> on Windows.  This behavior can be changed via the <code>RYE_HOME</code> environment variable.  This is useful if you do not like the default location of where Rye places it's configuration or if you need to isolate it.</p>"},{"location":"guide/config/#home-folder-structure","title":"Home Folder Structure","text":"<p>The <code>.rye</code> home folder contains both user configuration as well as Rye managed state such as installed toolchains.  The following files and folders are placed within the <code>.rye</code> folder.  Note that not all are there always.</p>"},{"location":"guide/config/#configtoml","title":"<code>config.toml</code>","text":"<p>This is a configuration file that influences how Rye operates.  Today very little configuration is available there.  For the available config keys see Config File.</p>"},{"location":"guide/config/#self","title":"<code>self</code>","text":"<p>While Rye is written in Rust, it uses a lot of Python tools internally.  These are maintained in an internal virtualenv stored in this location.</p>"},{"location":"guide/config/#py","title":"<code>py</code>","text":"<p>In this folder Rye stores the different toolchains.  Normally those are folders containing downloaded Python distributions, but they can also be symlinks or special reference files.</p>"},{"location":"guide/config/#shims","title":"<code>shims</code>","text":"<p>This folder contains shim binaries.  These binaries are for instance the <code>python</code> executable which automatically proxies to the current virtualenv or globally installed tools.</p>"},{"location":"guide/config/#config-file","title":"Config File","text":"<p>The config file <code>config.toml</code> in the <code>.rye</code> folder today only is used to manage defaults.  This is a fully annotated config file:</p> <pre><code>[default]\n# This is the default value that is written into new pyproject.toml\n# files for the `project.requires-python` key\nrequires-python = \"&gt;= 3.8\"\n\n# This is the default toolchain that is used\ntoolchain = \"cpython@3.11.1\"\n</code></pre>"},{"location":"guide/config/#per-project-config","title":"Per Project Config","text":"<p>For the project specific <code>pyproject.toml</code> config see pyproject.toml.</p>"},{"location":"guide/deps/","title":"Dependencies","text":"<p>Dependencies are declared in pyproject.toml however adding them can be simplified with the <code>rye add</code> command.  In the most simple invocation it adds a regular dependency, but it can be customized.</p>"},{"location":"guide/deps/#adding-basic-dependency","title":"Adding Basic Dependency","text":"<p>To add a regular dependency just invoke <code>rye add</code> with the name of the Python package:</p> <pre><code>rye add Flask\n</code></pre> <p>If you also want to define a version, use a PEP 508 requirement:</p> <pre><code>rye add \"Flask&gt;=2.0\"\n</code></pre> <p>For extra/feature dependencies you can either use PEP 508 syntax or use <code>--features</code>:</p> <pre><code>rye add \"Flask[dotenv]\"\nrye add Flask --features=dotenv\n</code></pre> <p>These dependencies are stored in <code>project.dependencies</code>.</p>"},{"location":"guide/deps/#development-dependencies","title":"Development Dependencies","text":"<p>For dependencies that should only be installed during development pass <code>--dev</code></p> <pre><code>rye add --dev black\n</code></pre> <p>These dependencies are stored in the non-standard <code>tool.rye.dev-dependencies</code> key.</p>"},{"location":"guide/deps/#git-local-dependencies","title":"Git / Local Dependencies","text":"<p>To add a local or git dependency, you can pass additional parameters like <code>--path</code> or <code>--git</code>:</p> <pre><code>rye add Flask --git=https://github.com/pallets/flask\nrye add My-Utility --path ./my-utility\n</code></pre> <p>Note that when adding such dependencies, it's necessary to also provide the name of the package.  Additionally for git dependencies all kinds of extra parameters such as <code>--tag</code>, <code>--rev</code> or <code>--branch</code> are supported.</p> <p>When working with local dependencies it's strongly encouraged to configure a workspace.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Rye is built in Rust. There is no binary distribution yet, it only works on Linux and macOS as of today.  You need to have Rust and Cargo installed.  If you don't have, you can use rustup to get them onto your machine.</p> <p>Afterwards you can install <code>Rye</code> via <code>cargo</code>:</p> <pre><code>cargo install --git https://github.com/mitsuhiko/rye rye\n</code></pre>"},{"location":"guide/installation/#add-shims-to-path","title":"Add Shims to Path","text":"<p>Once <code>rye</code> is installed you should also add <code>~/.rye/shims</code> into your <code>PATH</code>. This folder is a folder that contains \"shims\" which are executables that Rye manages for you.  For instance any Python installation managed by Rye will be available via a shim placed there.</p> <p>On macOS or Linux you can accomplish this by adding it to your <code>.bashrc</code>, <code>.zshrc</code> or similar.  This step is optional but required if you want to be able to just type <code>python</code> into the shell to pick up the current virtualenv's Python interpreter.  Likewise it's required if you want to take advantage of Rye's global tool installation feature.</p> BashZSHWindows <pre><code>echo 'export PATH=\"$HOME/.rye/shims:$PATH\"' &gt;&gt; ~/.bashrc\n</code></pre> <pre><code>echo 'export PATH=\"$HOME/.rye/shims:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre> <p>To modify the Windows PATH environment variable</p> <ol> <li>Press Win+R, enter <code>sysdm.cpl</code> and hit Enter.</li> <li>In the \"System Properties\" dialog, click the \"Advanced\" tab.</li> <li>Click on \"Environment Variables\".</li> <li>In the top list, double click on the <code>Path</code> variable.</li> <li>In the \"Edit environment variable\" dialog click on \"New\".</li> <li>Enter <code>%USERPROFILE%\\.rye\\shims</code> and hit Enter.</li> <li>Click repeatedly on \"Move Up\" until the newly added item is at the top.</li> <li>Click on \"OK\" and close the dialog.</li> </ol> <p>Note that you might need to restart your login session for this to take effect.</p>"},{"location":"guide/installation/#updating-rye","title":"Updating Rye","text":"<p>To update rye to the latest version you can use <code>rye</code> itself:</p> <pre><code>rye self update\n</code></pre>"},{"location":"guide/installation/#uninstalling","title":"Uninstalling","text":"<p>If you don't want to use Rye any more, you can use <code>cargo</code> to uninstall it again:</p> <pre><code>cargo uninstall rye\n</code></pre> <p>Additionally you should delete the <code>.rye</code> folder from your home directory and remove <code>~/.rye/shims</code> from the <code>Path</code> again.  Rye itself does not place any data in other locations.  Note though that virtual environments created by rye will no longer function after Rye was uninstalled.</p>"},{"location":"guide/pyproject/","title":"Python Project (<code>pyproject.toml</code>)","text":"<p>Rye tries to avoid a lot of proprietary configuration in the <code>pyproject.toml</code> file but a bit is necessary.  Here are the most important keys that Rye expects:</p>"},{"location":"guide/pyproject/#projectdependencies","title":"<code>project.dependencies</code>","text":"<p>This key is used to manage dependencies.  They work exactly like you expect from a regular <code>pyproject.toml</code> file and in fact Rye changes nothing about this.  However Rye is capable of modifying these entries with the <code>rye add</code> and <code>rye remove</code> commands.</p> <pre><code>[project]\ndependencies = [\n\"mkdocs~=1.4.3\",\n\"mkdocs-material~=9.1.12\",\n\"pymdown-extensions~=9.11\",\n]\n</code></pre>"},{"location":"guide/pyproject/#toolryedev-dependencies","title":"<code>tool.rye.dev-dependencies</code>","text":"<p>This works similar to <code>project.dependencies</code> but holds development only dependencies.  These can be added here automatically via <code>rye add --dev</code>.</p> <pre><code>[tool.rye]\ndev-dependencies = [\"black~=23.3.0\"]\n</code></pre> <p>Dev dependencies are installed automatically unless <code>--no-dev</code> is passed to <code>sync</code>.</p>"},{"location":"guide/pyproject/#toolryeexcluded-dependencies","title":"<code>tool.rye.excluded-dependencies</code>","text":"<p>This is a special key that contains dependencies which are never installed, even if they are pulled in as indirect dependencies.  These are added here automatically with <code>rye add --excluded</code>.</p> <pre><code>[tool.rye]\nexcluded-dependencies = [\"cffi\"]\n</code></pre>"},{"location":"guide/pyproject/#toolryemanaged","title":"<code>tool.rye.managed</code>","text":"<p>This is a purely informational key that tells rye that this project is supposed to be managed by Rye.  This key is not changing any behavior in Rye, but it's a hint to better aid the user experience.</p> <pre><code>[tool.rye]\nmanaged = true\n</code></pre>"},{"location":"guide/pyproject/#toolryescripts","title":"<code>tool.rye.scripts</code>","text":"<p>This key can be used to register custom scripts that are exposed via <code>rye run</code>.  Each key is a script, and each value is the configuration for that script.  Normally the value is an object with different keys with the most important key being <code>cmd</code> which holds the command to execute. However if only <code>cmd</code> is set, then the object is optional.  <code>cmd</code> itself can either be set to a string or an array of arguments.</p> <pre><code>[tool.rye.scripts]\n# These three options are equivalent:\ndevserver = \"flask run --app ./hello.py --debug\"\ndevserver-alt = [\"flask\", \"run\", \"--app\", \"./hello.py\", \"--debug\"]\ndevserver-explicit = { cmd = \"flask run --app ./hello.py --debug\" }\n</code></pre> <p>The following keys are possible for a script:</p>"},{"location":"guide/pyproject/#cmd","title":"<code>cmd</code>","text":"<p>The command to execute.  This is either a <code>string</code> or an <code>array</code> of arguments.  In either case shell specific interpolation is unavailable.  The command will invoke one of the tools in the virtualenv if it's available there.</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --app ./hello.py --debug\" }\nhttp = { cmd = [\"python\", \"-mhttp.server\", \"8000\"] }\n</code></pre>"},{"location":"guide/pyproject/#env","title":"<code>env</code>","text":"<p>This key can be used to provide environment variables with a script:</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --debug\", env = { FLASK_APP = \"./hello.py\" } }\n</code></pre>"},{"location":"guide/pyproject/#chain","title":"<code>chain</code>","text":"<p>This is a special key that can be set instead of <code>cmd</code> to make a command invoke multiple other commands.  Each command will be executed one after another.  If any of the commands fails the rest of the commands won't be executed and instead the chain fails.</p> <pre><code>[tool.rye.scripts]\nlint = { chain = [\"lint:black\", \"lint:flake8\" ] }\n\"lint:black\" = \"black --check src\"\n\"lint:flake8\" = \"flake8 src\"\n</code></pre>"},{"location":"guide/pyproject/#toolryeworkspace","title":"<code>tool.rye.workspace</code>","text":"<p>When a table with that key is stored, then a project is declared to be a workspace root.  By default all Python projects discovered in sub folders will then become members of this workspace and share a virtualenv.  Optionally the <code>members</code> key (an array) can be used to restrict these members.  In that list globs can be used.  The root project itself is always a member.</p> <pre><code>[tool.rye.workspace]\nmembers = [\"mylib-*\"]\n</code></pre>"},{"location":"guide/sync/","title":"Syncing and Locking","text":"<p>Rye currently uses pip-tools to download and install dependencies.  For this purpose it creates two \"lockfiles\" (called <code>requirements.lock</code> and <code>requirements-dev.lock</code>).  These are not real lockfiles but they fulfill a similar purpose until a better solution has been implemented.</p> <p>Whenever <code>rye sync</code> is called, it will update lockfiles as well as the virtualenv.  If you only want to update the lockfiles, then <code>rye lock</code> can be used.</p>"},{"location":"guide/sync/#lock","title":"Lock","text":"<p>When locking, some options can be provided to change the locking behavior.  These flags are also all available on <code>rye sync</code>.</p>"},{"location":"guide/sync/#-update-update-all","title":"<code>--update</code> / <code>--update-all</code>","text":"<p>Updates a specific or all requirements to the latest and greatest version.  Without this flag a dependency will only be updated if necessary.</p> <pre><code>rye lock --update-all\n</code></pre>"},{"location":"guide/sync/#-features-all-features","title":"<code>--features</code> / <code>--all-features</code>","text":"<p>Python packages can have extra dependencies.  By default the local package that is installed will only be installed with the default features.  If for instance you have an extra dependency this will only be installed if the feature is enabled.</p> <pre><code>rye add --optional=web flask\nrye lock --features=web\n</code></pre> <p>When working with workspaces, the package name needs to be prefixed with a slash:</p> <pre><code>rye lock --features=package-name/feature-name\n</code></pre> <p>The <code>--features</code> parameter can be passed multiple times and features can also be comma separated.  To turn on all features, the <code>--all-features</code> parameter can be used.</p> <pre><code>rye lock --all-features\n</code></pre>"},{"location":"guide/sync/#-pre","title":"<code>--pre</code>","text":"<p>By default updates and version resolution will not consider pre-releases of packages.  If you do want to include those, pass <code>--pre</code></p> <pre><code>rye lock Flask --pre\n</code></pre>"},{"location":"guide/sync/#sync","title":"Sync","text":"<p>Syncing takes the same parameters as <code>lock</code> and then some.  Sync will usually first do what <code>lock</code> does and then use the lockfiles to update the virtualenv.</p>"},{"location":"guide/sync/#-no-lock","title":"<code>--no-lock</code>","text":"<p>To prevent the lock step from automatically running, pass <code>--no-lock</code>.</p> <pre><code>rye sync --no-lock\n</code></pre>"},{"location":"guide/sync/#-no-dev","title":"<code>--no-dev</code>","text":"<p>Only sync based on the production lockfile (<code>requirements.lock</code>) instead of the development lockfile (<code>requirements-dev.lock</code>).</p> <pre><code>rye sync --no-dev\n</code></pre>"},{"location":"guide/toolchains/","title":"Toolchain Management","text":"<p>Rye is unique in that it does not use system Python installations.  Instead if downloads and manages Python installations itself (called toolchains).</p>"},{"location":"guide/toolchains/#pinning-toolchains","title":"Pinning Toolchains","text":"<p>To make a project use a specific toolchain write the name of the toolchain into the <code>.python-version</code> file or use the <code>pin</code> command.  For pinning <code>cpython</code> the <code>cpython@</code> prefix can be omitted.</p> <pre><code>rye pin cpython@3.11.4\n</code></pre> <p>Pinning a downloadable version means that Rye will automatically fetch it when necessary.</p>"},{"location":"guide/toolchains/#listing-toolchains","title":"Listing Toolchains","text":"<p>To see which toolchains are installed, <code>rye toolchain list</code> prints a list:</p> <p><pre><code>rye toolchain list\n</code></pre> <pre><code>cpython@3.11.1 (C:\\Users\\armin\\.rye\\py\\cpython@3.11.1\\install\\python.exe)\npypy@3.9.16 (C:\\Users\\armin\\.rye\\py\\pypy@3.9.16\\python.exe)\n</code></pre></p> <p>To see which toolchains can be installed, additionally pass the <code>--include-downloadable</code>:</p> <pre><code>rye toolchain list --include-downloadable\n</code></pre>"},{"location":"guide/toolchains/#fetching-toolchains","title":"Fetching Toolchains","text":"<p>Generally Rye automatically downloads toolchains, but they can be explicitly fetched with <code>rye toolchain fetch</code> (also aliased to <code>rye fetch</code>):</p> <pre><code>rye toolchain fetch cpython@3.8.5\n</code></pre> <p>Toolchains are fetched from two sources:</p> <ul> <li>Indygreg's Portable Python Builds for CPython</li> <li>PyPy.org for PyPy</li> </ul>"},{"location":"guide/toolchains/#registering-toolchains","title":"Registering Toolchains","text":"<p>Additionally it's possible to register an external toolchain with the <code>rye toolchain register</code> command.</p> <pre><code>rye toolchain register /path/to/python\n</code></pre> <p>The name of the toolchain is picked based on the interpreter.  For instance linking a regular cpython installation will be called <code>cpython@version</code>, whereas linking pypy would show up as <code>pypy@version</code>.  To override the name you can pass <code>--name</code>:</p> <pre><code>rye toolchain register --name=custom /path/to/python\n</code></pre>"},{"location":"guide/toolchains/#removing-toolchains","title":"Removing Toolchains","text":"<p>To remove an already fetched toolchain run <code>rye toolchain remove</code>.  Note that this also works for linked toolchains:</p> <pre><code>rye toolchain remove cpython@3.8.5\n</code></pre> <p>Warning</p> <p>Removing an actively used toolchain will render the virtualenvs that refer to use broken.</p>"},{"location":"guide/tools/","title":"Tools","text":"<p>Rye supports global tool installations.  This for instance allows you to install tools like <code>black</code> or <code>ruff</code> globally.</p>"},{"location":"guide/tools/#installing-tools","title":"Installing Tools","text":"<p>Use the <code>rye tool install</code> (aliased to <code>rye install</code>) command to install a tool globally with a shim:</p> <pre><code>rye install ruff\n</code></pre> <p>Afterwards the tool is installed into <code>~/.rye/tools/ruff</code> and the necessary shims are placed in <code>~/.rye/shims</code>.</p>"},{"location":"guide/tools/#listing-tools","title":"Listing Tools","text":"<p>If you want to see which tools are installed, you can use <code>rye tools list</code>:</p> <pre><code>rye tools list\n</code></pre> <pre><code>black\n  black\n  blackd\nruff\n  ruff\n</code></pre> <p>To also see which scripts those tools provide, also pass <code>--include-scripts</code></p> <pre><code>rye tools list --include-scripts\n</code></pre>"},{"location":"guide/tools/#uninstalling-tools","title":"Uninstalling Tools","text":"<p>To uninstall a tool again, use <code>rye tools uninstall</code> (aliased to <code>rye uninstall</code>):</p> <pre><code>rye uninstall black\n</code></pre>"}]}